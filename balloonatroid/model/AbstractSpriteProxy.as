/* PureMVC AS2 FlashLite Demo - Balloonatroid Copyright (c) 2007, 2008 by Cliff Hall <clifford.hall@puremvc.org> and  Chandima Cumaranatunge <chandima.cumaranatunge@puremvc.org> Your reuse is governed by the Creative Commons Attribution 3.0 License */import org.puremvc.as2.interfaces.*;import org.puremvc.as2.patterns.mediator.*;import org.puremvc.as2.patterns.observer.*;import balloonatroid.*;import balloonatroid.model.*;import balloonatroid.interfaces.*;/** * An Abstract class for Sprite Proxies. */class balloonatroid.model.AbstractSpriteProxy extends 			org.puremvc.as2.patterns.proxy.Proxy implements IProxy, IStateMachine{		/** Wander back and forth horizontally. */	public static var HORIZONTAL:String 	= "HORIZONTAL"		/** Wander back and forth vertically. */	public static var VERTICAL:String 		= "VERTICAL"		/** Wander in a circular motion. */	public static var CIRCULAR:String 		= "CIRCULAR"		/** Angle used to computer wander movement (in Radians). */	private var wanderAngle:Number = Math.PI;		/**	 * {@inheritDoc} 	 */	public function AbstractSpriteProxy( aName:String, dataObject:AbstractSpriteDO ) 	{		super( aName, dataObject );	}		/**	 * {@inheritDoc}	 */	public function changeState( aState : IState ) : Void 	{		if (sprite.currentState != null) 		{			sprite.currentState.exit(this);		}		sprite.previousState = sprite.currentState;		sprite.currentState = aState;		sprite.currentState.enter(this);	}		/**	 * {@inheritDoc} 	 */	public function update() : Void 	{		var currentTime:Number = getTimer();		if (sprite.currentState != null) 		{			sprite.currentState.execute(this);		}		sprite.lastUpdateTime = currentTime; // update time	}	 	/**	 * {@inheritDoc} 	 */	public function getCurrentState() : IState 	{		return sprite.currentState;	}		/**	 * {@inheritDoc} 	 */	public function getPreviousState() : IState 	{		return sprite.previousState;	}		/**	 * Move the sprite based on current speed and and time since last update.	 * Constrain to maximum speed.	 * Constrain to bounds if set.	 */	public function move():Void	{				var timeDiff = ( getTimer() - sprite.lastUpdateTime ) * 0.001; // seconds				// make sure speed is below max speed		sprite.speedX = ( Math.abs(sprite.speedX) > sprite.speedMax ) ? sprite.speedMax * sprite.speedX / Math.abs(sprite.speedX) : sprite.speedX;		sprite.speedY = ( Math.abs(sprite.speedY) > sprite.speedMax ) ? sprite.speedMax * sprite.speedY / Math.abs(sprite.speedY) : sprite.speedY;				// new location		var newX = sprite._x + ( sprite.speedX * timeDiff );		var newY = sprite._y + ( sprite.speedY * timeDiff );				// contrain within bounds if specified		sprite._x = ( sprite.hasBoundsX ) ? constrainX( newX ) : newX;		sprite._y = ( sprite.hasBoundsY ) ? constrainY( newY ) : newY;				//GameFacade.log.info('_x ' + sprite._x + ' _y ' + sprite._y + ' newX ' + newX + ' newY ' + newY + ' inertia ' + sprite.inertia);		//GameFacade.log.info('speedX ' + sprite.speedX + ' speedY ' + sprite.speedY + ' speedMax ' + sprite.speedMax + ' timeDiff ' + timeDiff);	}		/**	 * Move the sprite toward the current target applying inertia.	 */	public function arriveAtTarget():Void	{		// get distance		var distX = sprite.targetX - sprite._x;		var distY = sprite.targetY - sprite._y;				var timeDiff = ( getTimer() - sprite.lastUpdateTime ) * 0.001; // seconds				// speed depends on distance to target and inertia		sprite.speedX = distX * Math.abs(distX) / sprite.inertia;		sprite.speedY = distY * Math.abs(distY) / sprite.inertia;				move();	}		/**	 * Move the sprite toward the current target with overshooting.	 */	public function seekTarget():Void	{		// get distance		var distX = sprite.targetX - sprite._x;		var distY = sprite.targetY - sprite._y;				var timeDiff = ( getTimer() - sprite.lastUpdateTime ) * 0.001; // seconds				sprite.speedX += 0.9 * ( distX * Math.abs(distX) );		sprite.speedY += 0.9 * ( distY * Math.abs(distY) );				move();	}		/**	 * Flee from target at max speed.	 */	public function fleeFromTarget():Void	{		// get distance		var distX = sprite.targetX - sprite._x;		var distY = sprite.targetY - sprite._y;				var timeDiff = ( getTimer() - sprite.lastUpdateTime ) * 0.001; // seconds				sprite.speedX += 0.9 * ( - distX * Math.abs(distX) );		sprite.speedY += 0.9 * ( - distY * Math.abs(distY) );				move();	}		/**	 * Move the sprite back and forth based on {@link balloonatroid.model.AbstractSpriteDO#wanderMethod} setting.	 */	public function wanderAroundTarget():Void	{				var timeDiff = ( getTimer() - sprite.lastUpdateTime ) * 0.001; // seconds		// The form 'wanderAngle += timeDiff' does not work -- is this a bug?		var magnitude = Math.sin( wanderAngle += 0.05 ); // value between -1 and 1				switch (sprite.wanderMethod) 		{			case HORIZONTAL:				var distX = sprite.wanderRadius * magnitude;				break;			case VERTICAL:				var distY = sprite.wanderRadius * magnitude;				break;			case CIRCULAR:				var distX = sprite.wanderRadius * magnitude;				var distY = sprite.wanderRadius * magnitude;				break;		}						/*// new location (by placement rather than speed)		var newX = sprite.targetX + distX;		var newY = sprite.targetY + distY;				// contrain within bounds if specified		sprite._x = ( sprite.hasBoundsX ) ? constrainX( newX ) : newX;		sprite._y = ( sprite.hasBoundsY ) ? constrainY( newY ) : newY;*/				// new location		var newX = sprite.targetX + distX - sprite._x ;		var newY = sprite.targetY + distY - sprite._y ;				sprite.speedX += ( newX * Math.abs(newX) );		sprite.speedY += ( newY * Math.abs(newY) );				move();	}		/**	 * Get distance to target from current position.	 *	 * @return Distance in pixels.	 */	public function distanceToTarget():Number	{		return Math.sqrt((sprite.targetY - sprite._y) * (sprite.targetY - sprite._y) + 					(sprite.targetX - sprite._x) * (sprite.targetX - sprite._x));	}		/**	 * Set the target position for the sprite.	 *	 * @param newTargetX the new target for the x axis	 * @param newTargetY the new target for the y axis	 */	public function setTarget( newTargetX:Number, newTargetY:Number ):Void	{		sprite.targetX = newTargetX;		sprite.targetY = newTargetY;	}		/**	 * Set the target to the current sprite position.	 */	public function setTargetToCurrentPos():Void	{		sprite.targetX = sprite._x;		sprite.targetY = sprite._y;	}		/**	 * Adjust the target position for the sprite.	 *	 * @param offsetX the amount of offset for the x axis.	 * @param offsetY the amount of offset for the y axis.	 */	public function adjustTarget( offsetX:Number, offsetY:Number ):Void	{		sprite.targetX += offsetX;		sprite.targetY += offsetY;	}		/**	 * Set the speed components of the sprite.	 *	 * @param speedX the new speed for the x axis.	 * @param speedY the new speed for the y axis.	 */	public function setSpeed( speedX:Number, speedY:Number ):Void	{		sprite.speedX = speedX;		sprite.speedY = speedY;	}		/**	 * Add new speed components to the sprite.	 *	 * @param speedX the new speed for the x axis.	 * @param speedY the new speed for the y axis.	 */	public function addSpeed( speedX:Number, speedY:Number ):Void	{		sprite.speedX += speedX;		sprite.speedY += speedY;	}				/**	 * Set the wonder radius for the sprite.	 *	 * @param radius for the wondering circle.	 */	public function setWanderRadius( radius:Number ):Void	{		sprite.wanderRadius = radius;	}			/**	 * Set the target position for the sprite.	 *	 * @param newPositionX the new target for the x axis.	 * @param newPositionY the new target for the y axis.	 */	public function setPosition( newPositionX:Number, newPositionY:Number ):Void	{		sprite._x = newPositionX;		sprite._y = newPositionY;	}		/**	 * Constrain horizontal position to specified bounds.	 *	 * @param newX the new horizontal position.	 */	private function constrainX( newX:Number ):Number	{		// apply bounds check for X axis		if ( newX > sprite.upperBoundX || newX < sprite.lowerBoundX )		{			return sprite._x // stay put		} else {			return newX;		}	}		/**	 * Constrain vertical position to specified bounds.	 *	 * @param newY the new vertical position	 * @return Number the contrained vertical position	 */	private function constrainY( newY:Number ):Number	{		// apply bounds check for Y axis		if ( newY > sprite.upperBoundY || newY < sprite.lowerBoundY )		{			return sprite._y // stay put		} else {			return newY;		}	}			/**	 * Cast the Data Object to its actual type.	 * 	 * @return The Data Object cast to {@link balloonatroid.model.AbstractSpriteDO}	 */	public function get sprite():AbstractSpriteDO	{		return AbstractSpriteDO( data );	}}