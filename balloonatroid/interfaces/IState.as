/* PureMVC AS2 FlashLite Demo - Balloonatroid Copyright (c) 2007, 2008 by Cliff Hall <clifford.hall@puremvc.org> and  Chandima Cumaranatunge <chandima.cumaranatunge@puremvc.org> Your reuse is governed by the Creative Commons Attribution 3.0 License */import balloonatroid.interfaces.IStateMachine;/** * The interface definition for state object. * <P> * Game agent behavior is implemented using a Finite State Machine (FSM). FSM implementation * is based on Chapter 2 of the excellent book by Mat Buckland called * <em><a href="http://www.ai-junkie.com/books/toc_pgaibe.html">Programming Game AI by Example</a></em>. * <P> * Each stateful game entity implements a state machine ( {@code balloonatroid.interfaces.IStateMachine} )  * in its model, specifically in its proxy class. Each state in the statemachine is a unique class.  * <P> * Quite simply, the model for interactive game entities is the state machine. All model logic will be * implemented within each state object. The state interface declares methods that get executed  * when the state is entered, updated and exited allowing logic to be run on state entry, exit and * during state updates greatly increasing flexibility and clarity. * <P> * A reference to the model is passed to each state method to enable each state to access model properties * and methods. * <P> * If there is only one instance of a stateful game entity on stage at a given time such as a volley balloon, shield, * or boss, the state objects can be singletons. However, in the case of defenders state objects cannot be  * shared as there are several defenders on stage at the same time each having its own state machine. This  * requires the creation of a new state object each time the defender transitions into a different state. * * @see <a href="http://en.wikipedia.org/wiki/Finite_state_machine">Finite state machine</a> on Wikipedia. * @see <a href="http://www.ai-junkie.com/books/toc_pgaibe.html">Programming Game AI by Example</a> by Mat Buckland. */interface balloonatroid.interfaces.IState{	/**	 * The logic to be executed when the state is entered.	 *	 * This is where initial model properties for the particular state 	 * such as initial speed, state entry animations, initial position and start time can be set.	 *	 * @param IStateMachine Reference to the statemachine (model) that delegates this state.	 */	public function enter( sm : IStateMachine ) : Void;	/**	 * The logic to be executed when the state is exited.	 *	 * This is where cleanup can be conducted when leaving the state 	 * such as removing event listeners for garbage collection.	 *	 * @param IStateMachine Reference to the statemachine (model) that delegates this state.	 */    public function exit( sm : IStateMachine ) : Void;		/**	 * The logic to be executed when the state is updated.	 *	 * This is where model properties can be updated for the partcular state.	 * This method is usually called on each {@code EnterFrame} to update position,	 * conduct hit-testing etc.	 *	 * @param IStateMachine Reference to the statemachine (model) that delegates this state.	 */	public function execute( sm : IStateMachine ) : Void}